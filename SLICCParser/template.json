{"cache_header": "machine(MachineType:L1Cache, \"MSI cache\")\n    :   Sequencer *sequencer;\n        CacheMemory *cacheMemory;\n        bool send_evictions;\n\t    Cycles responseLatency := 1;\n\n        MessageBuffer *mandatoryQueue;\n\n        MessageBuffer *fwdTo, network=\"To\", virtual_network=\"2\", vnet_type=\"fwd\";\n        MessageBuffer *fwdFrom, network=\"From\", virtual_network=\"2\", vnet_type=\"fwd\";\n        MessageBuffer *respTo, network=\"To\", virtual_network=\"3\", vnet_type=\"resp\";\n        MessageBuffer *respFrom, network=\"From\", virtual_network=\"3\", vnet_type=\"resp\";\n        MessageBuffer *reqTo, network=\"To\", virtual_network=\"4\", vnet_type=\"req\";\n        MessageBuffer *reqFrom, network=\"From\", virtual_network=\"4\", vnet_type=\"req\";\n{\n    state_declaration(State, desc=\"Cache states\", default=\"L1Cache_State_I\") {\n        I, AccessPermission:Invalid, desc=\"invalid\";\n        I_load, AccessPermission:Invalid, desc=\"invalid load\";\n        I_load_Inv_I, AccessPermission:Invalid, desc=\"invalid load inv invalid\";\n        I_store, AccessPermission:Invalid, desc=\"invalid store\";\n        I_store_GetM_Ack_AD, AccessPermission:Invalid, desc=\"Invalidation store_GetM_Ack_AD\";\n        I_store_GetM_Ack_AD_Fwd_GetM_I, AccessPermission:Invalid, desc=\"Invalidation store_GetM_Ack_AD_Fwd_GetM_I\";\n        I_store_GetM_Ack_AD_Fwd_GetS_S, AccessPermission:Invalid, desc=\"Invalidation store_GetM_Ack_AD_Fwd_GetS_S\";\n        I_store_GetM_Ack_AD_Fwd_GetS_S_Inv_I, AccessPermission:Invalid, desc=\"Invalidation store_GetM_Ack_AD_Fwd_GetS_S_Inv_I\";\n        I_store_Fwd_GetM_I, AccessPermission:Invalid, desc=\"Invalidation store_Fwd_GetM_I\";\n        I_store_Fwd_GetS_S, AccessPermission:Invalid, desc=\"Invalidation store_Fwd_GetS_S\";\n        I_store_Fwd_GetS_S_Inv_I, AccessPermission:Invalid, desc=\"Invalidation store_Fwd_GetS_S_Inv_I\";\n        M, AccessPermission:Read_Write, desc=\"modified\";\n        M_evict, AccessPermission:Invalid, desc=\"modified eviction\";\n        M_evict_Fwd_GetM, AccessPermission:Invalid, desc=\"modified evict_Fwd_GetM\";\n        S, AccessPermission:Read_Only, desc=\"shared\";\n        S_evict, AccessPermission:Invalid, desc=\"shared evict\";\n        S_store, AccessPermission:Read_Only, desc=\"shared store\";\n        S_store_GetM_Ack_AD, AccessPermission:Read_Only, desc=\"shared store_GetM_Ack_AD\";\n        S_store_GetM_Ack_AD_Fwd_GetS_S, AccessPermission:Read_Only, desc=\"shared store_GetM_Ack_AD_Fwd_GetS_S\";\n        S_store_Fwd_GetS_S, AccessPermission:Read_Only, desc=\"shared store_GetM_Ack_AD_Fwd_GetS_S\";\n    }\n \n    enumeration(Event, desc=\"Cache events\") {\n        SloadSEvent, desc=\"S->S upon local load hit.\";\n        MloadMEvent, desc=\"M->M upon local load hit.\";\n        MstoreMEvent, desc=\"M->M upon local store hit.\";\n        deallocfwdfrom_in, desc=\"Event indicating the cacheMemory line should be deallocated following a message received on fwdfrom_in.\";\n        deallocrespfrom_in, desc=\"Event indicating the cacheMemory line should be deallocated following a message received on respfrom_in.\";\n        deallocreqfrom_in, desc=\"Event indicating the cacheMemory line should be deallocated following a message received on reqfrom_in.\";\n        allocI_store, desc=\"Event indicating cacheMemory entry alloc before moving to I_store.\";\n        allocI_load, desc=\"Event indicating cacheMemory entry alloc before moving to I_load.\";\n    }\n    \n    structure(Entry, desc=\"Stored variables of the  machine\", interface=\"AbstractCacheEntry\") {\n        State CacheState, desc=\"Cache state\";\n        DataBlock clL1, desc=\"data block\";\n        int acksReceivedL1, default=0, desc=\"received acks\";\n        int acksExpectedL1, default=0, desc=\"expected acks\";\n    }\n  \n    structure(TBE, desc=\"TBE entries for L1Cache machine\") {\n        Addr PhysicalAddress, desc=\"physical address\";\n        State TBEState,       desc=\"Transient State\";\n        DataBlock DataBlk,    desc=\"Data to be written\";\n    }\n  \n    structure(TBETable, external=\"yes\"){\n        TBE lookup(Addr);\n        void allocate(Addr);\n        void deallocate(Addr);\n        bool isPresent(Addr);\n    }\n  \n    TBETable TBEs, template=\"<L1Cache_TBE>\", constructor=\"m_number_of_TBEs\";\n  \n    void set_tbe(TBE b);\n    void unset_tbe();\n    Tick clockEdge();\n    void set_cache_entry(AbstractCacheEntry a);\n    void unset_cache_entry();\n  \n    MachineID mapAddressToMachine(Addr addr, MachineType mtype);\n    \n    Entry getCacheEntry(Addr LineAddress), return_by_pointer=\"yes\" {\n        return static_cast(Entry, \"pointer\", cacheMemory.lookup(LineAddress));\n    }\n  \n    State getState(TBE tbe, Entry cache_entry, Addr LineAddress) {\n        if (is_valid(tbe)) {\n            return tbe.TBEState;\n        } else if (is_valid(cache_entry)) {\n            return cache_entry.CacheState;\n        } else {\n            return State:I;\n        }\n    }\n  \n    void setState(TBE tbe, Entry cache_entry, Addr LineAddress, State state) {\n        if (is_valid(tbe)) {\n\t    //DPRINTF(RubySlicc, \"Switch %s -> %s\\n\", getState(tbe, cache_entry, LineAddress), state);\n            tbe.TBEState := state;\n        }\n        if (is_valid(cache_entry)) {\n\t    //DPRINTF(RubySlicc, \"Switch %s -> %s\\n\", getState(tbe, cache_entry, LineAddress), state);\n            cache_entry.CacheState := state;\n        }\n    }\n  \n    AccessPermission getAccessPermission(Addr LineAddress) {\n        TBE tbe := TBEs[LineAddress];\n        if (is_valid(tbe)) {\n            return L1Cache_State_to_permission(tbe.TBEState);\n        }\n        Entry cache_entry := getCacheEntry(LineAddress);\n        if (is_valid(cache_entry)) {\n            return L1Cache_State_to_permission(cache_entry.CacheState);\n        } else {\n            return AccessPermission:NotPresent;\n        }\n    }\n  \n    void setAccessPermission(Entry cache_entry, Addr LineAddress, State state) {\n        if (is_valid(cache_entry)) {\n            cache_entry.changePermission(L1Cache_State_to_permission(state));\n        }\n    }\n  \n    void functionalRead(Addr addr, Packet *pkt) {\n        TBE tbe := TBEs[addr];\n        if(is_valid(tbe)) {\n            testAndRead(addr, tbe.DataBlk, pkt);\n        } else {\n            testAndRead(addr, getCacheEntry(addr).clL1, pkt);\n        }\n    }\n  \n    int functionalWrite(Addr addr, Packet *pkt) {\n        int num_functional_writes := 0;\n    \n        TBE tbe := TBEs[addr];\n        if(is_valid(tbe)) {\n            num_functional_writes := num_functional_writes + testAndWrite(addr, tbe.DataBlk, pkt);\n            return num_functional_writes;\n        }\n    \n        num_functional_writes := num_functional_writes + testAndWrite(addr, getCacheEntry(addr).clL1, pkt);\n        return num_functional_writes;\n    }\n\n    out_port(fwdto_out, CoherenceMessage, fwdTo);\n    out_port(reqto_out, CoherenceMessage, reqTo);\n    out_port(respto_out, CoherenceMessage, respTo);", "cache_tail": "in_port(mandatory_in, RubyRequest, mandatoryQueue) {\n        if (mandatory_in.isReady(clockEdge())) {\n            peek(mandatory_in, RubyRequest, block_on=\"LineAddress\") {\n                Entry entry := getCacheEntry(in_msg.LineAddress);\n                TBE tbe := TBEs[in_msg.LineAddress];\n        \n                if (is_invalid(entry) && cacheMemory.cacheAvail(in_msg.LineAddress) == false ) {\n                    Addr LineAddress := cacheMemory.cacheProbe(in_msg.LineAddress);\n                    Entry entry := getCacheEntry(LineAddress);\n                    TBE tbe := TBEs[LineAddress];\n                    State st := getState(tbe, entry, LineAddress);\n                    if (st == State:M) {\n                        enqueue(reqto_out, CoherenceMessage, 1) {\n                            out_msg.LineAddress := LineAddress;\n                            out_msg.MessageSize := MessageSizeType:Data;\n                            out_msg.Destination.add(mapAddressToMachine(LineAddress, MachineType:Directory));\n                            out_msg.Type := CoherenceMessageType:PutM;\n                            out_msg.Sender := machineID;\n                            out_msg.cl := entry.clL1;\n                        }\n\t\t\t\t\t\tDPRINTF(RubySlicc, \"Switch %#x %s: evict -> M_evict\\n\", LineAddress, st);\n                        setState(tbe, entry, LineAddress, State:M_evict);\n                        if (send_evictions) {\n                            sequencer.evictionCallback(LineAddress);\n                        }\n                    } else if (st == State:S) {\n                        enqueue(reqto_out, CoherenceMessage, 1) {\n                            out_msg.LineAddress := LineAddress;\n                            out_msg.MessageSize := MessageSizeType:Data;\n                            out_msg.Destination.add(mapAddressToMachine(LineAddress, MachineType:Directory));\n                            out_msg.Type := CoherenceMessageType:PutS;\n                            out_msg.Sender := machineID;\n                        }\n\t\t\t\t\t\tDPRINTF(RubySlicc, \"Switch %#x %s: evict -> S_evict\\n\", LineAddress, st);\n                        setState(tbe, entry, LineAddress, State:S_evict);\n                        if (send_evictions) {\n                            sequencer.evictionCallback(LineAddress);\n                        }\n                    } else {\n                        // stall\n                    }\n                } else {\n                    State st := getState(tbe, entry, in_msg.LineAddress);\n                    Addr LineAddress := in_msg.LineAddress;\n                    if (in_msg.Type == RubyRequestType:LD || in_msg.Type == RubyRequestType:IFETCH) {\n                        if (st == State:I) {\n\t\t\t\t\t\t\tDPRINTF(RubySlicc, \"Switch %#x %s: %s -> I_load\\n\", LineAddress, st, in_msg.Type);\n                            trigger(Event:allocI_load, LineAddress, entry, tbe);\n                        } else if (st == State:M) {\n\t\t\t\t\t\t\tDPRINTF(RubySlicc, \"Switch %#x %s: %s -> M\\n\", LineAddress, st, in_msg.Type);\n                            trigger(Event:MloadMEvent, LineAddress, entry, tbe);\n                        } else if (st == State:S) {\n\t\t\t\t\t\t\tDPRINTF(RubySlicc, \"Switch %#x %s: %s -> S\\n\", LineAddress, st, in_msg.Type);\n                            trigger(Event:SloadSEvent, LineAddress, entry, tbe);\n                        } else {\n                            // stall\n                        }\n                    } else if (in_msg.Type == RubyRequestType:ST) {\n                        if (st == State:I) {\n\t\t\t\t\t\t\tDPRINTF(RubySlicc, \"Switch %#x %s: %s -> I_store\\n\", LineAddress, st, in_msg.Type);\n                            trigger(Event:allocI_store, LineAddress, entry, tbe);\n                        } else if (st == State:M) {\n\t\t\t\t\t\t\tDPRINTF(RubySlicc, \"Switch %#x %s: %s -> M\\n\", LineAddress, st, in_msg.Type);\n                            trigger(Event:MstoreMEvent, LineAddress, entry, tbe);\n                        } else if (st == State:S) {\n                            enqueue(reqto_out, CoherenceMessage, 1) {\n                                out_msg.LineAddress := LineAddress;\n                                out_msg.MessageSize := MessageSizeType:Data;\n                                out_msg.Destination.add(mapAddressToMachine(LineAddress, MachineType:Directory));\n                                out_msg.Type := CoherenceMessageType:Upgrade;\n                                out_msg.Sender := machineID;\n                            }\n                            entry.acksReceivedL1 := 0;\n\t\t\t\t\t\t\tDPRINTF(RubySlicc, \"Switch %#x %s: %s -> S_store\\n\", LineAddress, st, in_msg.Type);\n                            setState(tbe, entry, LineAddress, State:S_store);\n                            mandatory_in.dequeue(clockEdge());\n                        } else {\n                            // stall\n                        }\n                    } else {\n                        error(\"Unexpected message type from processor\");\n                    }\n                }\n            }\n        }\n    }\n\n    action(deallocEntry, \"d\", desc=\"Deallocate an entry\") {\n\t  APPEND_TRANSITION_COMMENT(\"deallocEntry\");\n\t  DPRINTF(RubySlicc, \"deallocEntry: %#x\\n\", address);\n      assert(is_valid(cache_entry));\n      cacheMemory.deallocate(address);\n      unset_cache_entry();\n    }\n\n    action(allocEntry, \"a\", desc=\"Allocate an entry\") {\n\t\tAPPEND_TRANSITION_COMMENT(\"allocEntry\");\n\t\tDPRINTF(RubySlicc, \"allocEntry\\n\");\n        assert(is_invalid(cache_entry));\n        assert(cacheMemory.cacheAvail(address));\n        set_cache_entry(cacheMemory.allocate(address, new Entry));\n    }\n\n    action(loadHit, \"Lh\", desc=\"Callback local load hit.\") {\n\t\tAPPEND_TRANSITION_COMMENT(\"loadHit\");\n\t\tDPRINTF(RubySlicc, \"loadHit: %#x\\n\", address);\n        assert(is_valid(cache_entry));\n        cacheMemory.setMRU(cache_entry);\n        sequencer.readCallback(address, cache_entry.clL1, false);\n    }\n  \n    action(storeHit, \"Sh\", desc=\"Callback local store hit.\") {\n\t\tAPPEND_TRANSITION_COMMENT(\"storeHit\");\n\t\tDPRINTF(RubySlicc, \"storeHit: %#x\\n\", address);\n        assert(is_valid(cache_entry));\n        cacheMemory.setMRU(cache_entry);\n        sequencer.writeCallback(address, cache_entry.clL1, false);\n    }\n    \n    action(popmandatory_in, \"pmandatory_in0\", desc=\"Pop the mandatory_in queue.\") {\n\t\tAPPEND_TRANSITION_COMMENT(\"popmandatory_in\");\n\t\tDPRINTF(RubySlicc, \"popmandatory_in\\n\");\n        mandatory_in.dequeue(clockEdge());\n\tDPRINTF(RubySlicc, \"popmandatory_in  finish\\n\");\n    }\n\n    action(popfwdfrom_in, \"pfwdfrom_in0\", desc=\"Pop the fwdfrom_in queue.\") {\n\t\tAPPEND_TRANSITION_COMMENT(\"popfwdfrom_in\");\n\t\tDPRINTF(RubySlicc, \"popfwdfrom_in\\n\");\n        fwdfrom_in.dequeue(clockEdge());\n    }\n\n    action(popreqfrom_in, \"preqfrom_in0\", desc=\"Pop the reqfrom_in queue.\") {\n\t\tAPPEND_TRANSITION_COMMENT(\"popreqfrom_in\");\n\t\tDPRINTF(RubySlicc, \"popreqfrom_in\\n\");\n        reqfrom_in.dequeue(clockEdge());\n    }\n\n    action(poprespfrom_in, \"prespfrom_in0\", desc=\"Pop the respfrom_in queue.\") {\n\t\tAPPEND_TRANSITION_COMMENT(\"poprespfrom_in\");\n\t\tDPRINTF(RubySlicc, \"poprespfrom_in\\n\");\n        respfrom_in.dequeue(clockEdge());\n    }\n\n    action(actionI_I_load, \"II0\", desc=\"TODO\") {\n\t\tAPPEND_TRANSITION_COMMENT(\"actionI_I_load\");\n\t\tDPRINTF(RubySlicc, \"actionI_I_load\\n\");\n        peek(mandatory_in, RubyRequest) {\n            //Entry entry := cache_entry;\n            Addr LineAddress := in_msg.LineAddress;\n            enqueue(reqto_out, CoherenceMessage, 1) {\n                out_msg.LineAddress := LineAddress;\n                out_msg.MessageSize := MessageSizeType:Data;\n                out_msg.Destination.add(mapAddressToMachine(LineAddress, MachineType:Directory));\n                out_msg.Type := CoherenceMessageType:GetS;\n                out_msg.Sender := machineID;\n                //out_msg.cl := entry.clL1;\n                ////out_msg.acksExpected := 0;\n            }\n        }\n    }\n\n    action(actionI_I_store, \"II1\", desc=\"TODO\") {\n\t\tAPPEND_TRANSITION_COMMENT(\"actionI_I_store\");\n\t\tDPRINTF(RubySlicc, \"actionI_I_store\\n\");\n        peek(mandatory_in, RubyRequest) {\n            Entry entry := cache_entry;\n            Addr LineAddress := in_msg.LineAddress;\n            enqueue(reqto_out, CoherenceMessage, 1) {\n                out_msg.LineAddress := LineAddress;\n                out_msg.MessageSize := MessageSizeType:Data;\n                out_msg.Destination.add(mapAddressToMachine(LineAddress, MachineType:Directory));\n                out_msg.Type := CoherenceMessageType:GetM;\n                out_msg.Sender := machineID;\n                //out_msg.cl := entry.clL1;\n                ////out_msg.acksExpected := 0;\n            }\n            entry.acksReceivedL1 := 0;\n        }\n    }\n\n    transition({I}, deallocfwdfrom_in) {\n\t    deallocEntry;\n\t\tpopfwdfrom_in;\n\t}\n\n\ttransition({I}, deallocreqfrom_in) {\n\t\tdeallocEntry;\n\t\tpopreqfrom_in;\n\t}\n    \n\ttransition({I}, deallocrespfrom_in) {\n\t\tdeallocEntry;\n\t\tpoprespfrom_in;\n\t}\n\n\ttransition(I, allocI_store, I_store) {\n\t\tallocEntry;\n\t\tactionI_I_store;\n\t\tpopmandatory_in;\n\t}\n\n\ttransition(I, allocI_load, I_load) {\n\t\tallocEntry;\n\t\tactionI_I_load;\n\t\tpopmandatory_in;\n\t}\n\n\ttransition(S, SloadSEvent, S) {\n\t\tloadHit;\n\t\tpopmandatory_in;\n\t}\n\n\ttransition(M, MloadMEvent, M) {\n\t\tloadHit;\n\t\tpopmandatory_in;\n\t}\n\n\ttransition(M, MstoreMEvent, M) {\n\t\tstoreHit;\n\t\tpopmandatory_in;\n\t}\n}", "message_header": "enumeration(CoherenceMessageType, desc=\"Types of request messages\") {", "message_tail": "}\n\nstructure(CoherenceMessage, desc=\"Used for Cache->Dir and Fwd messages\", interface=\"Message\") {\n    Addr LineAddress,                   desc=\"Physical address for this request\";\n    CoherenceMessageType Type,          desc=\"Type of message\";\n    MachineID Sender,                   desc=\"Node who initiated the request\";\n    NetDest Destination,                desc=\"Multicast destination mask\";\n    DataBlock cl,                       desc=\"data for the cache line\";\n    int acksExpected,                   desc=\"ack expected\";\n    MessageSizeType MessageSize,        desc=\"size category of the message\";\n\n    bool functionalRead(Packet *pkt) {\n        return false;\n    }\n\n    bool functionalWrite(Packet *pkt) {\n        return testAndWrite(LineAddress, cl, pkt);\n    }\n}", "dir": "machine(MachineType:Directory, \"Directory protocol\")\n    :\n      DirectoryMemory * directory;\n      Cycles toMemLatency := 1;\n    \n    MessageBuffer *forwardToCache, network=\"To\", virtual_network=\"1\", vnet_type=\"forward\";\n    MessageBuffer *responseToCache, network=\"To\", virtual_network=\"2\", vnet_type=\"response\";\n    MessageBuffer *responseFromCache, network=\"From\", virtual_network=\"2\", vnet_type=\"response\";\n    MessageBuffer *requestFromCache, network=\"From\", virtual_network=\"0\", vnet_type=\"request\";\n    \n\n{\n    state_declaration(State, desc=\"Directory states\", default=\"Directory_State_I\") {\n        I, AccessPermission:Read_Write,  desc=\"Invalid in the caches.\";\n        S, AccessPermission:Read_Only,   desc=\"At least one cache has the blk\";\n        M, AccessPermission:Invalid,     desc=\"A cache has the block in M\";\n        S_D, AccessPermission:Read_Write,      desc=\"...TODO...\";\n    }\n\n    \n    structure(Entry, desc=\"...\", interface=\"AbstractCacheEntry\", main=\"false\") {\n        State DirState,         desc=\"Directory state\";\n        NetDest Sharers,        desc=\"Sharers for this block\";\n        NetDest Owner,          desc=\"Owner of this block\";\n        DataBlock cl,           desc=\"data block\";\n    }\n\n    Tick clockEdge();\n    MachineID mapAddressToMachine(Addr addr, MachineType mtype);\n\n    Entry getDirectoryEntry(Addr addr), return_by_pointer = \"yes\" {\n        Entry dir_entry := static_cast(Entry, \"pointer\", directory.lookup(addr));\n        if (is_invalid(dir_entry)) {\n            dir_entry := static_cast(Entry, \"pointer\", directory.allocate(addr, new Entry));\n        }\n        return dir_entry;\n    }\n\n    State getState(Addr addr) {\n        if (directory.isPresent(addr)) {\n            return getDirectoryEntry(addr).DirState;\n        } else {\n            return State:I;\n        }\n    }\n\n    void setState(Addr addr, State state) {\n        if (directory.isPresent(addr)) {\n            if (state == State:M) {\n                DPRINTF(RubySlicc, \"Owner %s\\n\", getDirectoryEntry(addr).Owner);\n                assert(getDirectoryEntry(addr).Owner.count() == 1);\n                assert(getDirectoryEntry(addr).Sharers.count() == 0);\n            }\n\t    \n            getDirectoryEntry(addr).DirState := state;\n            if (state == State:I)  {\n                assert(getDirectoryEntry(addr).Owner.count() == 0);\n                assert(getDirectoryEntry(addr).Sharers.count() == 0);\n            }\n        }\n    }\n\n    AccessPermission getAccessPermission(Addr addr) {\n        if (directory.isPresent(addr)) {\n            Entry e := getDirectoryEntry(addr);\n            return Directory_State_to_permission(e.DirState);\n        } else  {\n            return AccessPermission:NotPresent;\n        }\n    }\n    void setAccessPermission(Addr addr, State state) {\n        if (directory.isPresent(addr)) {\n            Entry e := getDirectoryEntry(addr);\n            e.changePermission(Directory_State_to_permission(state));\n        }\n    }\n\n    void functionalRead(Addr addr, Packet *pkt) {\n        functionalMemoryRead(pkt);\n    }\n\n    int functionalWrite(Addr addr, Packet *pkt) {\n        if (functionalMemoryWrite(pkt)) {\n            return 1;\n        } else {\n            return 0;\n        }\n    }\n\n\n\n    out_port(fwdToCache_out, CoherenceMessage, forwardToCache);\n    out_port(respToCache_out, CoherenceMessage, responseToCache);\n\n    \n\n    in_port(respFromCache_in, CoherenceMessage, respFromCache) {\n        if (respFromCache_in.isReady(clockEdge())) {\n            peek(respFromCache_in, CoherenceMessage) {\n                Entry entry := getDirectoryEntry(in_msg.LineAddress);\n                State st := getState(in_msg.LineAddress);\n                Addr LineAddress := in_msg.LineAddress;\n                if (st == State:I) {\n                    if (in_msg.Type == CoherenceMessageType:GetM) {\n                        enqueue(respToCache_out, CoherenceMessage, 1) {\n                            out_msg.LineAddress := LineAddress;\n                            out_msg.Type := CoherenceMessageType:GetM_Ack_AD;\n                            out_msg.Sender := machineID;\n                            out_msg.Destination.add(in_msg.Sender);\n                            out_msg.cl := entry.cl;\n                            out_msg.acksExpected := entry.Sharers.count();\n                            out_msg.MessageSize := MessageSizeType:Control;\n                        } \n                        entry.Owner.clear();\n                        entry.Owner.add(in_msg.Sender);\n\t\t\t\t\t\tentry.Sharers.clear(); \n\t\t\t\t\t\tsetState(LineAddress, State:M);                \n                        respFromCache_in.dequeue(clockEdge());\n                    }else if (in_msg.Type == CoherenceMessageType:GetS){\n                        entry.Sharers.add(in_msg.Sender);\n                        enqueue(respToCache_out, CoherenceMessage, 1) {\n                            out_msg.LineAddress := LineAddress;\n                            out_msg.Type := CoherenceMessageType:Data;\n                            out_msg.Sender := machineID;\n                            out_msg.Destination.add(in_msg.Sender);\n                            out_msg.cl := entry.cl;\n                            //out_msg.acksExpected := 0;\n                            out_msg.MessageSize := MessageSizeType:Control;\n                        }\n                        setState(LineAddress, State:S);\n                        respFromCache_in.dequeue(clockEdge());\n                    }else if (in_msg.Type == CoherenceMessageType:PutM){\n                        enqueue(fwdToCache_out, CoherenceMessage, 1) {\n                            out_msg.LineAddress := LineAddress;\n                            out_msg.Type := CoherenceMessageType:Put_Ack;\n                            out_msg.Sender := machineID;\n                            out_msg.Destination.add(in_msg.Sender);\n                            //out_msg.cl := entry.cl;\n                            //out_msg.acksExpected := 0;\n                            out_msg.MessageSize := MessageSizeType:Control;\n                        }\n                        entry.Sharers.remove(in_msg.Sender);\n                        if (entry.Owner.isElement(in_msg.Sender)){\n                            entry.cl := in_msg.cl;\n\t\t\t\t\t\t\tentry.Owner.clear();\n\t\t\t\t\t\t\tentry.Sharers.clear();\n                            DPRINTF(RubySlicc, \"Switch %#x %s: %s -> I\\n\", LineAddress, st, in_msg.Type);\n                            setState(LineAddress, State:I);\n                        }else{\n\t\t\t\t\t\t\tentry.Owner.clear();\n\t\t\t\t\t\t\tentry.Sharers.clear();\n                            DPRINTF(RubySlicc, \"Switch %#x %s: %s -> I\\n\", LineAddress, st, in_msg.Type);\n                            setState(LineAddress, State:I);\n                        }\n                        respFromCache_in.dequeue(clockEdge());\n                    }else if (in_msg.Type == CoherenceMessageType:PutS){\n                        enqueue(fwdToCache_out, CoherenceMessage, 1) {\n                            out_msg.LineAddress := LineAddress;\n                            out_msg.Type := CoherenceMessageType:Put_Ack;\n                            out_msg.Sender := machineID;\n                            out_msg.Destination.add(in_msg.Sender);\n                            out_msg.cl := entry.cl;\n                            //out_msg.acksExpected := 0;\n                            out_msg.MessageSize := MessageSizeType:Control;\n                        }\n                        entry.Sharers.remove(in_msg.Sender);\n                        if (entry.Sharers.count() == 0){\n                    \t\tentry.Owner.clear();\n\t\t\t\t\t\t\tentry.Sharers.clear();\n                            DPRINTF(RubySlicc, \"Switch %#x %s: %s -> I\\n\", LineAddress, st, in_msg.Type);\n                            setState(LineAddress, State:I);\n                        }else{\n\t\t\t\t\t\t\tentry.Owner.clear();\n\t\t\t\t\t\t\tentry.Sharers.clear();\n                            DPRINTF(RubySlicc, \"Switch %#x %s: %s -> I\\n\", LineAddress, st, in_msg.Type);\n                            setState(LineAddress, State:I);\n                        }\n                        respFromCache_in.dequeue(clockEdge());\n                    }else if (in_msg.Type == CoherenceMessageType:Upgrade){\n                        enqueue(respToCache_out, CoherenceMessage, 1) {\n                            out_msg.LineAddress := LineAddress;\n                            out_msg.Type := CoherenceMessageType:GetM_Ack_AD;\n                            out_msg.Sender := machineID;\n                            out_msg.Destination.add(in_msg.Sender);\n                            out_msg.cl := entry.cl;\n                            out_msg.acksExpected := entry.Sharers.count();\n                            out_msg.MessageSize := MessageSizeType:Control;\n                        }\n\t\t\t\t\t\tentry.Owner.clear();\n                        entry.Owner.add(in_msg.Sender);\n\t\t\t\t\t\tentry.Sharers.clear(); \n                        DPRINTF(RubySlicc, \"Switch %#x %s: %s -> M\\n\", LineAddress, st, in_msg.Type);\n                        setState(LineAddress, State:M);\n                        respFromCache_in.dequeue(clockEdge());\n                    }else{\n                        // stall\n                    }\n                }else if (st == State:M){\n                    if (in_msg.Type == CoherenceMessageType:GetM){\n                        enqueue(fwdToCache_out, CoherenceMessage, 1) {\n                            out_msg.LineAddress := LineAddress;\n                            out_msg.Type := CoherenceMessageType:Fwd_GetM;\n                            out_msg.Sender := in_msg.Sender;\n                            out_msg.Destination.addNetDest(entry.Owner);\n                            //out_msg.cl := entry.cl;\n                            //out_msg.acksExpected := 0;\n                            out_msg.MessageSize := MessageSizeType:Control;\n                        }\n                        entry.Owner.clear();\n                        entry.Owner.add(in_msg.Sender);\n\t\t\t\t\t\tentry.Sharers.clear(); \n                        DPRINTF(RubySlicc, \"Switch %#x %s: %s -> M\\n\", LineAddress, st, in_msg.Type);\n                        setState(LineAddress, State:M);\n                        respFromCache_in.dequeue(clockEdge());\n                    }else if(in_msg.Type == CoherenceMessageType:GetS){\n                        enqueue(fwdToCache_out, CoherenceMessage, 1) {\n                            out_msg.LineAddress := LineAddress;\n                            out_msg.Type := CoherenceMessageType:Fwd_GetS;\n                            out_msg.Sender := in_msg.Sender;\n                            out_msg.Destination.addNetDest(entry.Owner);\n                            //out_msg.cl := entry.cl;\n                            //out_msg.acksExpected := 0;\n                            out_msg.MessageSize := MessageSizeType:Control;\n                        }\n                        entry.Sharers.add(in_msg.Sender);\n                        entry.Sharers.addNetDest(entry.Owner);\n                        DPRINTF(RubySlicc, \"Switch %#x %s: %s -> M_GetS\\n\", LineAddress, st, in_msg.Type);\n                        setState(LineAddress, State:M_GetS);\n                        respFromCache_in.dequeue(clockEdge());\n                    }else if(in_msg.Type == CoherenceMessageType:PutM){\n                        enqueue(fwdToCache_out, CoherenceMessage, 1) {\n                            out_msg.LineAddress := LineAddress;\n                            out_msg.Type := CoherenceMessageType:Put_Ack;\n                            out_msg.Sender := machineID;\n                            out_msg.Destination.add(in_msg.Sender);\n                            //out_msg.cl := entry.cl;\n                            //out_msg.acksExpected := 0;\n                            out_msg.MessageSize := MessageSizeType:Control;\n                        }\n                        entry.Sharers.remove(in_msg.Sender);\n                        if (entry.Owner.isElement(in_msg.Sender)){\n                            entry.cl := in_msg.cl;\n\t\t\t\t\t\t\tentry.Owner.clear();\n\t\t\t\t\t\t\tentry.Sharers.clear();\n                            DPRINTF(RubySlicc, \"Switch %#x %s: %s -> I\\n\", LineAddress, st, in_msg.Type);\n                            setState(LineAddress, State:I);\n                        }else{\n\t\t\t\t\t\t\tentry.Sharers.clear(); \n                            DPRINTF(RubySlicc, \"Switch %#x %s: %s -> M\\n\", LineAddress, st, in_msg.Type);\n                            setState(LineAddress, State:M);\n                        }\n                        respFromCache_in.dequeue(clockEdge());\n                    }else if(in_msg.Type == CoherenceMessageType:PutS){\n                        enqueue(fwdToCache_out, CoherenceMessage, 1) {\n                            out_msg.LineAddress := LineAddress;\n                            out_msg.Type := CoherenceMessageType:Put_Ack;\n                            out_msg.Sender := machineID;\n                            out_msg.Destination.add(in_msg.Sender);\n                            out_msg.cl := entry.cl;\n                            //out_msg.acksExpected := 0;\n                            out_msg.MessageSize := MessageSizeType:Control;\n                        }\n                        entry.Sharers.remove(in_msg.Sender);\n                        if (entry.Sharers.count() == 0){\n\t\t\t\t\t\t\tentry.Sharers.clear(); \n                            DPRINTF(RubySlicc, \"Switch %#x %s: %s -> M\\n\", LineAddress, st, in_msg.Type);\n                            setState(LineAddress, State:M);\n                        }else{\n\t\t\t\t\t\t\tentry.Sharers.clear(); \n                            DPRINTF(RubySlicc, \"Switch %#x %s: %s -> M\\n\", LineAddress, st, in_msg.Type);\n                            setState(LineAddress, State:M);\n                        }\n                        respFromCache_in.dequeue(clockEdge());\n                    }else if(in_msg.Type == CoherenceMessageType:Upgrade){\n                        enqueue(fwdToCache_out, CoherenceMessage, 1) {\n                            out_msg.LineAddress := LineAddress;\n                            out_msg.Type := CoherenceMessageType:Fwd_GetM;\n                            out_msg.Sender := in_msg.Sender;\n                            out_msg.Destination.addNetDest(entry.Owner);\n                            //out_msg.cl := entry.cl;\n                            //out_msg.acksExpected := 0;\n                            out_msg.MessageSize := MessageSizeType:Control;\n                        }\n                        entry.Owner.clear();\n                        entry.Owner.add(in_msg.Sender);\n\t\t\t\t\t\tentry.Sharers.clear(); \n                        DPRINTF(RubySlicc, \"Switch %#x %s: %s -> M\\n\", LineAddress, st, in_msg.Type);\n                        setState(LineAddress, State:M);\n                        respFromCache_in.dequeue(clockEdge());\n                    }else{\n                        // stall\n                    }\n                }else if (st == State:S){\n                    if (in_msg.Type == CoherenceMessageType:GetM){\n\t\t\t    if (entry.Sharers.isElement(in_msg.Sender)){\n\t\t                    entry.Sharers.remove(in_msg.Sender);\n\t\t                    enqueue(respToCache_out, CoherenceMessage, 1) {\n                                out_msg.LineAddress := LineAddress;\n                                out_msg.Type := CoherenceMessageType:GetM_Ack_AD;\n                                out_msg.Sender := machineID;\n                                out_msg.Destination.add(in_msg.Sender);\n                                out_msg.cl := entry.cl;\n                                out_msg.acksExpected := entry.Sharers.count();\n                                out_msg.MessageSize := MessageSizeType:Control;\n                            }\n\t\t\t\t\t\t\t//entry.Sharers.clear(); \n                            DPRINTF(RubySlicc, \"Switch %#x %s: %s -> M\\n\", LineAddress, st, in_msg.Type);\n\t\t                    //setState(LineAddress, State:M);\n                            //entry.Sharers.remove(in_msg.Sender);\n                            enqueue(fwdToCache_out, CoherenceMessage, 1) {\n                                out_msg.LineAddress := LineAddress;\n                                out_msg.Type := CoherenceMessageType:Inv;\n                                out_msg.Sender := in_msg.Sender; //(1)\n                                out_msg.Destination.addNetDest(entry.Sharers);\n                                //out_msg.cl := entry.cl;\n                                //out_msg.acksExpected := 0;\n                                out_msg.MessageSize := MessageSizeType:Control;\n                            }\n\t\t                    entry.Owner.clear();\n                            entry.Owner.add(in_msg.Sender);\n\t\t                    entry.Sharers.clear();\n                            setState(LineAddress, State:M);\n\t\t                    respFromCache_in.dequeue(clockEdge());\n                        }else{\n                            enqueue(respToCache_out, CoherenceMessage, 1) {\n                                out_msg.LineAddress := LineAddress;\n                                out_msg.Type := CoherenceMessageType:GetM_Ack_AD;\n                                out_msg.Sender := machineID;//(5)\n                                out_msg.Destination.add(in_msg.Sender);\n                                out_msg.cl := entry.cl;\n                                out_msg.acksExpected := entry.Sharers.count();\n                                out_msg.MessageSize := MessageSizeType:Control;\n                            }\n\t\t\t\t\t\t\t//entry.Sharers.clear(); \n                            DPRINTF(RubySlicc, \"Switch %#x %s: %s -> M\\n\", LineAddress, st, in_msg.Type);\n                            //setState(LineAddress, State:M);\n                            entry.Sharers.remove(in_msg.Sender);\n                            enqueue(fwdToCache_out, CoherenceMessage, 1) {\n                                out_msg.LineAddress := LineAddress;\n                                out_msg.Type := CoherenceMessageType:Inv;\n                                out_msg.Sender := in_msg.Sender;\n                                out_msg.Destination.addNetDest(entry.Sharers);\n                                //out_msg.cl := entry.cl;\n                                //out_msg.acksExpected := 0;\n                                out_msg.MessageSize := MessageSizeType:Control;\n                            }\n                            entry.Owner.clear();\n                            entry.Owner.add(in_msg.Sender);\n                            entry.Sharers.clear();\n                            setState(LineAddress, State:M);\n                            respFromCache_in.dequeue(clockEdge());\n                        }\n                    }else if (in_msg.Type == CoherenceMessageType:GetS){\n                        entry.Sharers.add(in_msg.Sender);\n                        enqueue(respToCache_out, CoherenceMessage, 1) {\n                            out_msg.LineAddress := LineAddress;\n                            out_msg.Type := CoherenceMessageType:GetS_Ack;\n                            out_msg.Sender := machineID;\n                            out_msg.Destination.add(in_msg.Sender);\n                            out_msg.cl := in_msg.cl;\n                            //out_msg.acksExpected := 0;\n                            out_msg.MessageSize := MessageSizeType:Control;\n                        }\n                        DPRINTF(RubySlicc, \"Switch %#x %s: %s -> S\\n\", LineAddress, st, in_msg.Type);\n                        setState(LineAddress, State:S);\n                        respFromCache_in.dequeue(clockEdge());\n                    }else if (in_msg.Type == CoherenceMessageType:PutM){\n                       enqueue(fwdToCache_out, CoherenceMessage, 1) {\n                            out_msg.LineAddress := LineAddress;\n                            out_msg.Type := CoherenceMessageType:Put_Ack;\n                            out_msg.Sender := machineID;\n                            out_msg.Destination.add(in_msg.Sender);\n                            //out_msg.cl := in_msg.cl;\n                            //out_msg.acksExpected := 0;\n                            out_msg.MessageSize := MessageSizeType:Control;\n                        }\n                        entry.Sharers.remove(in_msg.Sender);\n                        if (entry.Owner.isElement(in_msg.Sender)){\n                            entry.cl := in_msg.cl;\n                            DPRINTF(RubySlicc, \"Switch %#x %s: %s -> S\\n\", LineAddress, st, in_msg.Type);\n                            setState(LineAddress, State:S);\n                        }else{\n                            DPRINTF(RubySlicc, \"Switch %#x %s: %s -> S\\n\", LineAddress, st, in_msg.Type);\n                            setState(LineAddress, State:S);\n                        }\n                        respFromCache_in.dequeue(clockEdge());\n                    }else if (in_msg.Type == CoherenceMessageType:PutS){\n                        enqueue(fwdToCache_out, CoherenceMessage, 1) {\n                            out_msg.LineAddress := LineAddress;\n                            out_msg.Type := CoherenceMessageType:Put_Ack;\n                            out_msg.Sender := machineID;\n                            out_msg.Destination.add(in_msg.Sender);\n                            out_msg.cl := entry.cl;\n                            //out_msg.acksExpected := 0;\n                            out_msg.MessageSize := MessageSizeType:Control;\n                        }\n                        entry.Sharers.remove(in_msg.Sender);\n                        if (entry.Sharers.count() == 0){\n           \t\t\t\t\tentry.Owner.clear();\n\t\t\t\t\t\t\tentry.Sharers.clear();\n                            DPRINTF(RubySlicc, \"Switch %#x %s: %s -> I\\n\", LineAddress, st, in_msg.Type);\n                            setState(LineAddress, State:I);\n                        }else{\n                            DPRINTF(RubySlicc, \"Switch %#x %s: %s -> S\\n\", LineAddress, st, in_msg.Type);\n                            setState(LineAddress, State:S);\n                        }\n                        respFromCache_in.dequeue(clockEdge());\n                    }else if (in_msg.Type == CoherenceMessageType:Upgrade){\n                        if (entry.Sharers.isElement(in_msg.Sender)){\n                            entry.Sharers.remove(in_msg.Sender);\n                            enqueue(respToCache_out, CoherenceMessage, 1) {\n                                out_msg.LineAddress := LineAddress;\n                                out_msg.Type := CoherenceMessageType:GetM_Ack_AD;\n                                out_msg.Sender := machineID;\n                                out_msg.Destination.add(in_msg.Sender);\n                                out_msg.cl := entry.cl;\n                                out_msg.acksExpected := entry.Sharers.count();\n                                out_msg.MessageSize := MessageSizeType:Control;\n                            }\n                            DPRINTF(RubySlicc, \"Switch %#x %s: %s -> M\\n\", LineAddress, st, in_msg.Type);\n                            //setState(LineAddress, State:M);\n                            enqueue(fwdToCache_out, CoherenceMessage, 1) {\n                                out_msg.LineAddress := LineAddress;\n                                out_msg.Type := CoherenceMessageType:Inv;\n                                out_msg.Sender := in_msg.Sender;\n                                out_msg.Destination.addNetDest(entry.Sharers);\n                                //out_msg.cl := entry.cl;\n                                //out_msg.acksExpected := 0;\n                                out_msg.MessageSize := MessageSizeType:Control;\n                            }\n                            entry.Owner.clear();\n                            entry.Owner.add(in_msg.Sender);\n                            entry.Sharers.clear();\n                            setState(LineAddress, State:M);\n                            respFromCache_in.dequeue(clockEdge());\n                        }else{\n                            enqueue(respToCache_out, CoherenceMessage, 1) {\n                                out_msg.LineAddress := LineAddress;\n                                out_msg.Type := CoherenceMessageType:GetM_Ack_AD;\n                                out_msg.Sender := machineID;\n                                out_msg.Destination.add(in_msg.Sender);\n                                out_msg.cl := entry.cl;\n                                out_msg.acksExpected := entry.Sharers.count();\n                                out_msg.MessageSize := MessageSizeType:Control;\n                            }\n                            DPRINTF(RubySlicc, \"Switch %#x %s: %s -> M\\n\", LineAddress, st, in_msg.Type);\n                            //setState(LineAddress, State:M);\n\t\t\t\t\t\t\tentry.Sharers.remove(in_msg.Sender);//(2)\n                            enqueue(fwdToCache_out, CoherenceMessage, 1) {\n                                out_msg.LineAddress := LineAddress;\n                                out_msg.Type := CoherenceMessageType:Inv;\n                                out_msg.Sender := in_msg.Sender;\n                                out_msg.Destination.addNetDest(entry.Sharers);\n                                //out_msg.cl := entry.cl;\n                                //out_msg.acksExpected := 0;\n                                out_msg.MessageSize := MessageSizeType:Control;\n                            }\n                            entry.Owner.clear();\n                            entry.Owner.add(in_msg.Sender);\n                            entry.Sharers.clear();\n                            setState(LineAddress, State:M);\n                            respFromCache_in.dequeue(clockEdge());\n                        }\n                    }else{\n                        // stall\n                    }\n                }else if (st == State:M_GetS){\n                    if(in_msg.Type == CoherenceMessageType:WB){\n                        if (entry.Owner.isElement(in_msg.Sender)){\n                            entry.cl := in_msg.cl;\n                            DPRINTF(RubySlicc, \"Switch %#x %s: %s -> S\\n\", LineAddress, st, in_msg.Type);\n                            setState(LineAddress, State:S);\n                        }else{\n                            DPRINTF(RubySlicc, \"Switch %#x %s: %s -> M_GetS\\n\", LineAddress, st, in_msg.Type);\n                            setState(LineAddress, State:M_GetS);\n                        }\n                        respFromCache_in.dequeue(clockEdge());\n                    }else{\n                        //stall\n                    }\n                }else{\n                    // stall\n                }\n            }\n        }\n    }\n\n    in_port(reqFromCache_in, CoherenceMessage, reqFromCache) {\n        if (reqFromCache_in.isReady(clockEdge())) {\n            peek(reqFromCache_in, CoherenceMessage) {\n                Entry entry := getDirectoryEntry(in_msg.LineAddress);\n                State st := getState(in_msg.LineAddress);\n                Addr LineAddress := in_msg.LineAddress;\n                if (st == State:I) {\n                    if (in_msg.Type == CoherenceMessageType:GetM) {\n                        enqueue(respToCache_out, CoherenceMessage, 1) {\n                            out_msg.LineAddress := LineAddress;\n                            out_msg.Type := CoherenceMessageType:Data;\n                            out_msg.Sender := machineID;\n                            out_msg.Destination.add(in_msg.Sender);\n                            out_msg.cl := entry.cl;\n                            out_msg.MessageSize := MessageSizeType:Data;\n                            if (entry.Owner.isElement(in_msg.Sender)){\n                                out_msg.Acks := entry.Sharers.count();\n                            }else{\n                                out_msg.Acks := 0;\n                            }\n                        }\n                        entry.Owner.clear();\n                        entry.Owner.add(in_msg.Sender);\n\t\t\t\t\t\tentry.Sharers.clear(); \n                        DPRINTF(RubySlicc, \"Switch %#x %s: %s -> M\\n\", LineAddress, st, in_msg.Type);\n\t\t\t\t\t\tsetState(LineAddress, State:M);                \n                        reqFromCache_in.dequeue(clockEdge());\n                    }else if (in_msg.Type == CoherenceMessageType:GetS){\n                        entry.Sharers.add(in_msg.Sender);\n                        enqueue(respToCache_out, CoherenceMessage, 1) {\n                            out_msg.LineAddress := LineAddress;\n                            out_msg.Type := CoherenceMessageType:Data;\n                            out_msg.Sender := machineID;\n                            out_msg.Destination.add(in_msg.Sender);\n                            out_msg.cl := entry.cl;\n                            out_msg.MessageSize := MessageSizeType:Data;\n                            if (entry.Owner.isElement(in_msg.Sender)){\n                                out_msg.Acks := entry.Sharers.count();\n                            }else{\n                                out_msg.Acks := 0;\n                            }\n                        }\n                        DPRINTF(RubySlicc, \"Switch %#x %s: %s -> S\\n\", LineAddress, st, in_msg.Type);\n                        setState(LineAddress, State:S);\n                        reqFromCache_in.dequeue(clockEdge());\n                    }else if (in_msg.Type == CoherenceMessageType:PutM){\n                        if (entry.Owner.isElement(in_msg.Sender)){\n                            reqFromCache_in.dequeue(clockEdge());\n                        }else{\n                            enqueue(fwdToCache_out, CoherenceMessage, 1) {\n                                out_msg.LineAddress := LineAddress;\n                                out_msg.Type := CoherenceMessageType:Put_Ack;\n                                out_msg.Sender := machineID;\n                                out_msg.Destination.add(in_msg.Sender);\n                                //out_msg.cl := entry.cl;\n                                //out_msg.acksExpected := 0;\n                                out_msg.MessageSize := MessageSizeType:Control;\n                            }\n\t\t\t\t\t\t\tentry.Owner.clear();\n\t\t\t\t\t\t\tentry.Sharers.clear();\n                            DPRINTF(RubySlicc, \"Switch %#x %s: %s -> I\\n\", LineAddress, st, in_msg.Type);\n                            setState(LineAddress, State:I);\n                        }\n                        reqFromCache_in.dequeue(clockEdge());\n                    }else if (in_msg.Type == CoherenceMessageType:PutS){\n                        enqueue(fwdToCache_out, CoherenceMessage, 1) {\n                            out_msg.LineAddress := LineAddress;\n                            out_msg.Type := CoherenceMessageType:Put_Ack;\n                            out_msg.Sender := machineID;\n                            out_msg.Destination.add(in_msg.Sender);\n                            out_msg.cl := entry.cl;\n                            //out_msg.acksExpected := 0;\n                            out_msg.MessageSize := MessageSizeType:Control;\n                        }\n                        entry.Sharers.remove(in_msg.Sender);\n                        if (entry.Sharers.count() == 0){\n                    \t\tentry.Owner.clear();\n\t\t\t\t\t\t\tentry.Sharers.clear();\n                            DPRINTF(RubySlicc, \"Switch %#x %s: %s -> I\\n\", LineAddress, st, in_msg.Type);\n                            setState(LineAddress, State:I);\n                        }else{\n\t\t\t\t\t\t\tentry.Owner.clear();\n\t\t\t\t\t\t\tentry.Sharers.clear();\n                            DPRINTF(RubySlicc, \"Switch %#x %s: %s -> I\\n\", LineAddress, st, in_msg.Type);\n                            setState(LineAddress, State:I);\n                        }\n                        reqFromCache_in.dequeue(clockEdge());\n                    }else if (in_msg.Type == CoherenceMessageType:Upgrade){\n                        enqueue(respToCache_out, CoherenceMessage, 1) {\n                            out_msg.LineAddress := LineAddress;\n                            out_msg.Type := CoherenceMessageType:GetM_Ack_AD;\n                            out_msg.Sender := machineID;\n                            out_msg.Destination.add(in_msg.Sender);\n                            out_msg.cl := entry.cl;\n                            out_msg.acksExpected := entry.Sharers.count();\n                            out_msg.MessageSize := MessageSizeType:Control;\n                        }\n\t\t\tentry.Owner.clear();\n                        entry.Owner.add(in_msg.Sender);\n\t\t\tentry.Sharers.clear(); \n                        DPRINTF(RubySlicc, \"Switch %#x %s: %s -> M\\n\", LineAddress, st, in_msg.Type);\n                        setState(LineAddress, State:M);\n                        reqFromCache_in.dequeue(clockEdge());\n                    }else{\n                        // stall\n                    }\n                }else if (st == State:M){\n                    if (in_msg.Type == CoherenceMessageType:GetM){\n                        enqueue(fwdToCache_out, CoherenceMessage, 1) {\n                            out_msg.LineAddress := LineAddress;\n                            out_msg.Type := CoherenceMessageType:Fwd_GetM;\n                            out_msg.Sender := in_msg.Sender;\n                            out_msg.Destination.addNetDest(entry.Owner);\n                            //out_msg.cl := entry.cl;\n                            //out_msg.acksExpected := 0;\n                            out_msg.MessageSize := MessageSizeType:Control;\n                        }\n                        entry.Owner.clear();\n                        entry.Owner.add(in_msg.Sender);\n\t\t\t\t\t\tentry.Sharers.clear(); \n                        DPRINTF(RubySlicc, \"Switch %#x %s: %s -> M\\n\", LineAddress, st, in_msg.Type);\n                        setState(LineAddress, State:M);\n                        reqFromCache_in.dequeue(clockEdge());\n                    }else if(in_msg.Type == CoherenceMessageType:GetS){\n                        enqueue(fwdToCache_out, CoherenceMessage, 1) {\n                            out_msg.LineAddress := LineAddress;\n                            out_msg.Type := CoherenceMessageType:Fwd_GetS;\n                            out_msg.Sender := in_msg.Sender;\n                            out_msg.Destination.addNetDest(entry.Owner);\n                            //out_msg.cl := entry.cl;\n                            //out_msg.acksExpected := 0;\n                            out_msg.MessageSize := MessageSizeType:Control;\n                        }\n                        entry.Sharers.add(in_msg.Sender);\n                        entry.Sharers.addNetDest(entry.Owner);\n                        DPRINTF(RubySlicc, \"Switch %#x %s: %s -> M_GetS\\n\", LineAddress, st, in_msg.Type);\n                        setState(LineAddress, State:M_GetS);\n                        reqFromCache_in.dequeue(clockEdge());\n                    }else if(in_msg.Type == CoherenceMessageType:PutM){\n                        enqueue(fwdToCache_out, CoherenceMessage, 1) {\n                            out_msg.LineAddress := LineAddress;\n                            out_msg.Type := CoherenceMessageType:Put_Ack;\n                            out_msg.Sender := machineID;\n                            out_msg.Destination.add(in_msg.Sender);\n                            //out_msg.cl := entry.cl;\n                            //out_msg.acksExpected := 0;\n                            out_msg.MessageSize := MessageSizeType:Control;\n                        }\n                        entry.Sharers.remove(in_msg.Sender);\n                        if (entry.Owner.isElement(in_msg.Sender)){\n                            entry.cl := in_msg.cl;\n\t\t\t\t\t\t\tentry.Owner.clear();\n\t\t\t\t\t\t\tentry.Sharers.clear();\n                            DPRINTF(RubySlicc, \"Switch %#x %s: %s -> I\\n\", LineAddress, st, in_msg.Type);\n                            setState(LineAddress, State:I);\n                        }else{\n\t\t\t\t\t\t\tentry.Sharers.clear(); \n                            DPRINTF(RubySlicc, \"Switch %#x %s: %s -> M\\n\", LineAddress, st, in_msg.Type);\n                            setState(LineAddress, State:M);\n                        }\n                        reqFromCache_in.dequeue(clockEdge());\n                    }else if(in_msg.Type == CoherenceMessageType:PutS){\n                        enqueue(fwdToCache_out, CoherenceMessage, 1) {\n                            out_msg.LineAddress := LineAddress;\n                            out_msg.Type := CoherenceMessageType:Put_Ack;\n                            out_msg.Sender := machineID;\n                            out_msg.Destination.add(in_msg.Sender);\n                            out_msg.cl := entry.cl;\n                            //out_msg.acksExpected := 0;\n                            out_msg.MessageSize := MessageSizeType:Control;\n                        }\n                        entry.Sharers.remove(in_msg.Sender);\n                        if (entry.Sharers.count() == 0){\n\t\t\t\t\t\t\tentry.Sharers.clear(); \n                            DPRINTF(RubySlicc, \"Switch %#x %s: %s -> M\\n\", LineAddress, st, in_msg.Type);\n                            setState(LineAddress, State:M);\n                        }else{\n\t\t\t\t\t\t\tentry.Sharers.clear(); \n                            DPRINTF(RubySlicc, \"Switch %#x %s: %s -> M\\n\", LineAddress, st, in_msg.Type);\n                            setState(LineAddress, State:M);\n                        }\n                        reqFromCache_in.dequeue(clockEdge());\n                    }else if(in_msg.Type == CoherenceMessageType:Upgrade){\n                        enqueue(fwdToCache_out, CoherenceMessage, 1) {\n                            out_msg.LineAddress := LineAddress;\n                            out_msg.Type := CoherenceMessageType:Fwd_GetM;\n                            out_msg.Sender := in_msg.Sender;\n                            out_msg.Destination.addNetDest(entry.Owner);\n                            //out_msg.cl := entry.cl;\n                            //out_msg.acksExpected := 0;\n                            out_msg.MessageSize := MessageSizeType:Control;\n                        }\n                        entry.Owner.clear();\n                        entry.Owner.add(in_msg.Sender);\n\t\t\t\t\t\tentry.Sharers.clear(); \n                        DPRINTF(RubySlicc, \"Switch %#x %s: %s -> M\\n\", LineAddress, st, in_msg.Type);\n                        setState(LineAddress, State:M);\n                        reqFromCache_in.dequeue(clockEdge());\n                    }else{\n                        // stall\n                    }\n                }else if (st == State:S){\n                    if (in_msg.Type == CoherenceMessageType:GetM){\n\t\t\t    if (entry.Sharers.isElement(in_msg.Sender)){\n\t\t                    entry.Sharers.remove(in_msg.Sender);\n\t\t                    enqueue(respToCache_out, CoherenceMessage, 1) {\n                                out_msg.LineAddress := LineAddress;\n                                out_msg.Type := CoherenceMessageType:GetM_Ack_AD;\n                                out_msg.Sender := machineID;\n                                out_msg.Destination.add(in_msg.Sender);\n                                out_msg.cl := entry.cl;\n                                out_msg.acksExpected := entry.Sharers.count();\n                                out_msg.MessageSize := MessageSizeType:Control;\n                            }\n\t\t\t\t\t\t\t//entry.Sharers.clear(); \n                            DPRINTF(RubySlicc, \"Switch %#x %s: %s -> M\\n\", LineAddress, st, in_msg.Type);\n\t\t                    //setState(LineAddress, State:M);\n                            //entry.Sharers.remove(in_msg.Sender);\n                            enqueue(fwdToCache_out, CoherenceMessage, 1) {\n                                out_msg.LineAddress := LineAddress;\n                                out_msg.Type := CoherenceMessageType:Inv;\n                                out_msg.Sender := in_msg.Sender;//(3)\n                                out_msg.Destination.addNetDest(entry.Sharers);\n                                //out_msg.cl := entry.cl;\n                                //out_msg.acksExpected := 0;\n                                out_msg.MessageSize := MessageSizeType:Control;\n                            }\n\t\t                    entry.Owner.clear();\n                            entry.Owner.add(in_msg.Sender);\n\t\t                    entry.Sharers.clear();\n                            setState(LineAddress, State:M);\n\t\t                    reqFromCache_in.dequeue(clockEdge());\n                        }else{\n                            enqueue(respToCache_out, CoherenceMessage, 1) {\n                                out_msg.LineAddress := LineAddress;\n                                out_msg.Type := CoherenceMessageType:GetM_Ack_AD;\n                                out_msg.Sender := machineID;//(6)\n                                out_msg.Destination.add(in_msg.Sender);\n                                out_msg.cl := entry.cl;\n                                out_msg.acksExpected := entry.Sharers.count();\n                                out_msg.MessageSize := MessageSizeType:Control;\n                            }\n\t\t\t\t\t\t\t//entry.Sharers.clear(); \n                            DPRINTF(RubySlicc, \"Switch %#x %s: %s -> M\\n\", LineAddress, st, in_msg.Type);\n                            //setState(LineAddress, State:M);\n                            entry.Sharers.remove(in_msg.Sender);\n                            enqueue(fwdToCache_out, CoherenceMessage, 1) {\n                                out_msg.LineAddress := LineAddress;\n                                out_msg.Type := CoherenceMessageType:Inv;\n                                out_msg.Sender := in_msg.Sender;\n                                out_msg.Destination.addNetDest(entry.Sharers);\n                                //out_msg.cl := entry.cl;\n                                //out_msg.acksExpected := 0;\n                                out_msg.MessageSize := MessageSizeType:Control;\n                            }\n                            entry.Owner.clear();\n                            entry.Owner.add(in_msg.Sender);\n                            entry.Sharers.clear();\n                            setState(LineAddress, State:M);\n                            reqFromCache_in.dequeue(clockEdge());\n                        }\n                    }else if (in_msg.Type == CoherenceMessageType:GetS){\n                        entry.Sharers.add(in_msg.Sender);\n                        enqueue(respToCache_out, CoherenceMessage, 1) {\n                            out_msg.LineAddress := LineAddress;\n                            out_msg.Type := CoherenceMessageType:GetS_Ack;\n                            out_msg.Sender := machineID;\n                            out_msg.Destination.add(in_msg.Sender);\n                            out_msg.cl := in_msg.cl;\n                            //out_msg.acksExpected := 0;\n                            out_msg.MessageSize := MessageSizeType:Control;\n                        }\n                        DPRINTF(RubySlicc, \"Switch %#x %s: %s -> S\\n\", LineAddress, st, in_msg.Type);\n                        setState(LineAddress, State:S);\n                        reqFromCache_in.dequeue(clockEdge());\n                    }else if (in_msg.Type == CoherenceMessageType:PutM){\n                       enqueue(fwdToCache_out, CoherenceMessage, 1) {\n                            out_msg.LineAddress := LineAddress;\n                            out_msg.Type := CoherenceMessageType:Put_Ack;\n                            out_msg.Sender := machineID;\n                            out_msg.Destination.add(in_msg.Sender);\n                            //out_msg.cl := in_msg.cl;\n                            //out_msg.acksExpected := 0;\n                            out_msg.MessageSize := MessageSizeType:Control;\n                        }\n                        entry.Sharers.remove(in_msg.Sender);\n                        if (entry.Owner.isElement(in_msg.Sender)){\n                            entry.cl := in_msg.cl;\n                            DPRINTF(RubySlicc, \"Switch %#x %s: %s -> S\\n\", LineAddress, st, in_msg.Type);\n                            setState(LineAddress, State:S);\n                        }else{\n                            DPRINTF(RubySlicc, \"Switch %#x %s: %s -> S\\n\", LineAddress, st, in_msg.Type);\n                            setState(LineAddress, State:S);\n                        }\n                        reqFromCache_in.dequeue(clockEdge());\n                    }else if (in_msg.Type == CoherenceMessageType:PutS){\n                        enqueue(fwdToCache_out, CoherenceMessage, 1) {\n                            out_msg.LineAddress := LineAddress;\n                            out_msg.Type := CoherenceMessageType:Put_Ack;\n                            out_msg.Sender := machineID;\n                            out_msg.Destination.add(in_msg.Sender);\n                            out_msg.cl := entry.cl;\n                            //out_msg.acksExpected := 0;\n                            out_msg.MessageSize := MessageSizeType:Control;\n                        }\n                        entry.Sharers.remove(in_msg.Sender);\n                        if (entry.Sharers.count() == 0){\n           \t\t\t\t\tentry.Owner.clear();\n\t\t\t\t\t\t\tentry.Sharers.clear();\n                            DPRINTF(RubySlicc, \"Switch %#x %s: %s -> I\\n\", LineAddress, st, in_msg.Type);\n                            setState(LineAddress, State:I);\n                        }else{\n                            DPRINTF(RubySlicc, \"Switch %#x %s: %s -> S\\n\", LineAddress, st, in_msg.Type);\n                            setState(LineAddress, State:S);\n                        }\n                        reqFromCache_in.dequeue(clockEdge());\n                    }else if (in_msg.Type == CoherenceMessageType:Upgrade){\n                        if (entry.Sharers.isElement(in_msg.Sender)){\n                            entry.Sharers.remove(in_msg.Sender);\n                            enqueue(respToCache_out, CoherenceMessage, 1) {\n                                out_msg.LineAddress := LineAddress;\n                                out_msg.Type := CoherenceMessageType:GetM_Ack_AD;\n                                out_msg.Sender := machineID;\n                                out_msg.Destination.add(in_msg.Sender);\n                                out_msg.cl := entry.cl;\n                                out_msg.acksExpected := entry.Sharers.count();\n                                out_msg.MessageSize := MessageSizeType:Control;\n                            }\n                            DPRINTF(RubySlicc, \"Switch %#x %s: %s -> M\\n\", LineAddress, st, in_msg.Type);\n                            //setState(LineAddress, State:M);\n                            enqueue(fwdToCache_out, CoherenceMessage, 1) {\n                                out_msg.LineAddress := LineAddress;\n                                out_msg.Type := CoherenceMessageType:Inv;\n                                out_msg.Sender := in_msg.Sender;\n                                out_msg.Destination.addNetDest(entry.Sharers);\n                                //out_msg.cl := entry.cl;\n                                //out_msg.acksExpected := 0;\n                                out_msg.MessageSize := MessageSizeType:Control;\n                            }\n                            entry.Owner.clear();\n                            entry.Owner.add(in_msg.Sender);\n                            entry.Sharers.clear();\n                            setState(LineAddress, State:M);\n                            reqFromCache_in.dequeue(clockEdge());\n                        }else{\n                            enqueue(respToCache_out, CoherenceMessage, 1) {\n                                out_msg.LineAddress := LineAddress;\n                                out_msg.Type := CoherenceMessageType:GetM_Ack_AD;\n                                out_msg.Sender := machineID;\n                                out_msg.Destination.add(in_msg.Sender);\n                                out_msg.cl := entry.cl;\n                                out_msg.acksExpected := entry.Sharers.count();\n                                out_msg.MessageSize := MessageSizeType:Control;\n                            }\n                            DPRINTF(RubySlicc, \"Switch %#x %s: %s -> M\\n\", LineAddress, st, in_msg.Type);\n                            //setState(LineAddress, State:M);\n\t\t\t\t\t\t\tentry.Sharers.remove(in_msg.Sender);//(4)\n                            enqueue(fwdToCache_out, CoherenceMessage, 1) {\n                                out_msg.LineAddress := LineAddress;\n                                out_msg.Type := CoherenceMessageType:Inv;\n                                out_msg.Sender := in_msg.Sender;\n                                out_msg.Destination.addNetDest(entry.Sharers);\n                                //out_msg.cl := entry.cl;\n                                //out_msg.acksExpected := 0;\n                                out_msg.MessageSize := MessageSizeType:Control;\n                            }\n                            entry.Owner.clear();\n                            entry.Owner.add(in_msg.Sender);\n                            entry.Sharers.clear();\n                            setState(LineAddress, State:M);\n                            reqFromCache_in.dequeue(clockEdge());\n                        }\n                    }else{\n                        // stall\n                    }\n                }else if (st == State:M_GetS){\n                    if(in_msg.Type == CoherenceMessageType:WB){\n                        if (entry.Owner.isElement(in_msg.Sender)){\n                            entry.cl := in_msg.cl;\n                            DPRINTF(RubySlicc, \"Switch %#x %s: %s -> S\\n\", LineAddress, st, in_msg.Type);\n                            setState(LineAddress, State:S);\n                        }else{\n                            DPRINTF(RubySlicc, \"Switch %#x %s: %s -> M_GetS\\n\", LineAddress, st, in_msg.Type);\n                            setState(LineAddress, State:M_GetS);\n                        }\n                        reqFromCache_in.dequeue(clockEdge());\n                    }else{\n                        //stall\n                    }\n                }else{\n                    // stall\n                }\n            }\n        }\n    }\n}\n"}